#include "imgfam.h"
#include "config.h"
#include <libgen.h>

/**
 * @brief Generates the first layer of the filter .
 *   Uses images generated by gen_patterns.sh
 *   which should be in CFG_DATAROOTDIR/digits/layer_1_*.png.
 * @return the familly of images representing the first layer.
 */
ImgFam * getLayer1() {
    ImgFam * answer=newImgFam(6);
    for (int i=0;i<6;++i) {
        char s[99];
        sprintf(s,"%s/digits/layer_1_%d.png",CFG_DATAROOTDIR,i);
        Img*img=newImgRead(s);
        Img*img2 = imgInvert(img);
        img2->data[2+5*2]=0;
        Img*img3 = imgSetWeight(img2,1000);
        imgFamSetImg(answer,i,img3);
        deleteImg(img2);
        deleteImg(img);
    }
    imgFamCalibrate(answer);
    return answer;
}

void generateLayer2 (int n) {
    ImgFam * firstLevelFilters=getLayer1();
    char s[99];
    sprintf(s,"%s/digits/reference_%d.png",CFG_DATAROOTDIR,n);
    Img * tmpimg = newImgRead(s);
    Img * img = imgInvert(tmpimg);
    deleteImg(tmpimg);
    ImgFam * firstLayerOutput =
        imgFamApplyConvolution(firstLevelFilters,img,imgIntFilterMinMax);
    
    ImgFam * firstLayerMaxPoolOutput=imgFamDownSampleMax(firstLayerOutput,2,2);
    ImgFam * avgPool=imgFamDownSampleMax(firstLayerMaxPoolOutput,2,2);
    
    char exportBaseName[99];
    sprintf(exportBaseName,"%s/digits/layer_2_Digit%d",CFG_DATAROOTDIR,n);
    imgFamWrite(avgPool,exportBaseName);
    // free allocated memory
    deleteImg(img);
    deleteImgFam(firstLevelFilters);
    deleteImgFam(firstLayerOutput);
    deleteImgFam(firstLayerMaxPoolOutput);
    deleteImgFam(avgPool);
}

/**
 * @brief Creates images of characters 1 to 9.
 * @param directory where to create the images
 * @param numFonts number of fonts to create.
 */
void generateImageOfFont(char*directory,int numFonts) {
    char * tmpFile = (char*)malloc(strlen(directory)+40);
    sprintf(tmpFile,"%s/generate_png_from_font.sh",directory);
    FILE * f = fopen(tmpFile,"w");
    HERE(tmpFile);
    fprintf(f,"#/bin/sh\n");
    fprintf(f,"# this file has been automatically generated\n");
    fprintf(f,"set -e\n");
    fprintf(f,"cd `dirname $0`\n");
    fprintf(f,"fonts=(`convert -list font  | grep Font: | grep -vi emoji| sed -e s/Font:// | tr -d ' '`)\n");
    fprintf(f,"fmax=${#fonts[@]}\n");
    fprintf(f,"fmax=$[fmax-1]\n");
    fprintf(f,"if [ $fmax -gt %d ]; then\n",numFonts);
    fprintf(f,"    fmax=%d\n",numFonts);
    fprintf(f,"fi\n");
    fprintf(f,"for f in `seq 0 $fmax`; do\n");
    fprintf(f,"    for i in `seq 1 9`; do\n");
    fprintf(f,"        convert -background white -fill black -font ${fonts[$f]} -size 28x28 -gravity center \"caption:$i\" $[f+1]_$i.png\n");
    fprintf(f,"    done\n");
    fprintf(f,"done\n");
    fclose(f);
    char cmd[99];
    sprintf(cmd,"bash %s",tmpFile);
    HERE(cmd);
    if (system(cmd)) {
        ERROR("Command failed, maybe 'convert' not found: ",cmd);
    }
}

void generateLayer3() {
    char tmpDirName[60];
    //memset(tmpDirName,0,60);
    createTmpDir(tmpDirName,15);
    int numFonts=30;
    generateImageOfFont(tmpDirName,numFonts);
    FILE * layer3File = fopen("l3.c","w");
    for (int f=1;f<=numFonts;++f) {
        char font[80];
        //sprintf(font,"%s/digits/reference",CFG_DATAROOTDIR);
        sprintf(font,"%s/%d",tmpDirName,f);
        
        ImgFam * firstLevelFilters=getLayer1();
        ImgFam * secondLevelFilters[10];
        for (int i=1;i<10;++i) {
            char baseName[99];
            sprintf(baseName,"%s/digits/layer_2_Digit%d",CFG_DATAROOTDIR,i);
            secondLevelFilters[i] = imgFamRead(baseName);
        }
        HERE("+++");
        HERE(font);
        unsigned char ** outputFromLevel2 = (unsigned char**)malloc(sizeof(char*)*11);
        
        for (int digit=0;digit<10;++digit) {
            outputFromLevel2[digit]=(unsigned char*)malloc(sizeof(char)*11);
        }
        for (int digit=1;digit<10;++digit) {
            char s[99];
            sprintf(s,"%s_%d.png",font,digit);
            Img * tmpimg = newImgRead(s);
            Img * img = imgInvert(tmpimg);
            deleteImg(tmpimg);
            
            ImgFam * firstLayerOutput =
                imgFamApplyConvolution(firstLevelFilters,img,imgIntFilterMinMax);
            
            ImgFam * firstLayerMaxPoolOutput=imgFamDownSampleMax(firstLayerOutput,2,2);
            ImgFam * avgPool=imgFamDownSampleMax(firstLayerMaxPoolOutput,2,2);
            
            HERE("___");
            int maxIndex=-1;
            int maxVal=-1;
            for (int i=1;i<10;++i) {
                Img*singlePixelImg=imgFamScalar(avgPool,secondLevelFilters[i]);
                //HERED(singlePixelImg->data[0]);
                outputFromLevel2[digit][i]=singlePixelImg->data[0];
                printf(" %d\n",singlePixelImg->data[0]);
                if (singlePixelImg->data[0]>maxVal) {
                    maxVal=singlePixelImg->data[0];
                    maxIndex=i;
                }
            }
            if (maxIndex!=digit) {
                fprintf(stderr,
                        "\033[31m%s:%d: ||| wrong index %d should be %d\033[m\n",       
                        __FILE__,                                   
                        __LINE__,                                   
                        maxIndex,
                        digit);
            } else {
                HERE("OK");
            }
        }
        for (int digit=1;digit<10;++digit) {
            fprintf(layer3File,"unsigned char tmp_arr_%d_%d[10]={0,",f,digit);
            for (int i=1;i<10;++i) {
                fprintf(layer3File,"%d%s",outputFromLevel2[digit][i],i==9?"":",");
            }
            fprintf(layer3File,"};\n");
        }
    }
    
    fprintf(layer3File,"unsigned char **digits[%d];\n",numFonts+1);    
    fprintf(layer3File,"unsigned char** init_digits() {\n");
    fprintf(layer3File,"    unsigned char** answer = (unsigned char**) malloc(sizeof(char**)*%d*10);\n",numFonts+1);
    for (int f=1;f<=numFonts;++f) {
        fprintf(layer3File,
                "    digits[%d]=answer+10*%d;\n",f,f);
        fprintf(layer3File,
                "    digits[%d][0]=NULL;\n",f);
        for (int digit=1;digit<10;++digit) {
            fprintf(layer3File,
                    // digits[a][b][c] char
                    // digits[a][b]    char*
                    // digits[a]       char**
                    // digits          char***
                    // answer[0]=
                    "    digits[%d][%d]=tmp_arr_%d_%d;\n",
                    f,digit,
                    f,digit);
        }
    }
    fprintf(layer3File,"    return answer;\n");
    fprintf(layer3File,"}\n");
    fclose(layer3File);
    HERE("l3.c written.");
}

void testFilterForDigit(char * font) {
    ImgFam * firstLevelFilters=getLayer1();
    ImgFam * secondLevelFilters[10];
    for (int i=1;i<10;++i) {
        char baseName[99];
        sprintf(baseName,"%s/digits/layer_2_Digit%d",CFG_DATAROOTDIR,i);
        secondLevelFilters[i] = imgFamRead(baseName);
    }
    HERE("+++");
    HERE(font);
    for (int digit=1;digit<10;++digit) {
        char s[99];
        sprintf(s,"%s_%d.png",font,digit);
        Img * tmpimg = newImgRead(s);
        Img * img = imgInvert(tmpimg);
        deleteImg(tmpimg);
        
        ImgFam * firstLayerOutput =
            imgFamApplyConvolution(firstLevelFilters,img,imgIntFilterMinMax);
    
        ImgFam * firstLayerMaxPoolOutput=imgFamDownSampleMax(firstLayerOutput,2,2);
        ImgFam * avgPool=imgFamDownSampleMax(firstLayerMaxPoolOutput,2,2);

        HERE("___");
        int maxIndex=-1;
        int maxVal=-1;
        for (int i=1;i<10;++i) {
            Img*singlePixelImg=imgFamScalar(avgPool,secondLevelFilters[i]);
            //HERED(singlePixelImg->data[0]);
            printf(" %d\n",singlePixelImg->data[0]);
            if (singlePixelImg->data[0]>maxVal) {
                maxVal=singlePixelImg->data[0];
                maxIndex=i;
            }
        }
        if (maxIndex!=digit) {
            fprintf(stderr,
                    "\033[31m%s:%d: ||| wrong index %d should be %d\033[m\n",       
                    __FILE__,                                   
                    __LINE__,                                   
                    maxIndex,
                    digit);
        } else {
            HERE("OK");
        }
    }
}


void generateTestData() {
    char tmpDirName[60];
    //memset(tmpDirName,0,60);
    createTmpDir(tmpDirName,15);
    int numFonts=30;
    generateImageOfFont(tmpDirName,numFonts);
    for (int i=1;i<=numFonts;++i) {
        char fontpath[99];
        sprintf(fontpath,"%s/%d",tmpDirName,i);
        testFilterForDigit(fontpath);
        //testFilterForDigit("/Users/fabrice/cnn/share/digits/reference");
        //sprintf(fontpath,"%s/share/digits/reference/%d",CFG_DEFAULT_PREFIX,i);
        //testFilterForDigit(fontpath);
        //testFilterForDigit("/Users/fabrice/git/cnn/dataset/digits/2");
    }
}

/** 
 * @brief Tells how to use this program.
 * @param f where to write the info.
 * @param name the value of argv[0].
 */
void digitsUsage(FILE*f,char*name) {
    char * bname=basename(name);
    fprintf(f,"%s usage:\n", bname);
    fprintf(f,"    %s [ options ]\n", bname);
    fprintf(f,"Where option is one of:\n");
    fprintf(f,"    [-c|--create] <n>:\n");
    fprintf(f,"         creates the filters to detect digits for layer <n> \n");
    fprintf(f,"         in directory:\n");
    fprintf(f,"             %s/digits\n",CFG_DATAROOTDIR);
    fprintf(f,"    [-t|--test] :\n");
    fprintf(f,"         tests the filters for digits.\n");
    fprintf(f,"    [-h|--help] :\n");
    fprintf(f,"         display this help message and exits.\n");
}

/**
 * @brief main program for the digit executable. Parses options from 
 * the command line.
 * @param argc number of arguments given
 * @param argv value of arguments.
 * @return 0 if no error occurs.
 */
int digitsMain(int argc,char**argv) {
    int i=1;
    
    while (i<argc) {
        if (strcmp(argv[i],"--create")==0 ||
            strcmp(argv[i],"-c")==0 ) {
            ++i;
            if (i>=argc) {
                digitsUsage(stderr,argv[0]);
                ERROR("-c|--create expects the number of layer to generate","");
            }
            int l = atoi(argv[i]);
            if (l!=2 && l!=3) {
                digitsUsage(stderr,argv[0]);
                ERROR("-c|--create 2 or 3 as argument","");
            }
            if (l==2) {
                for (int i=1;i<10;++i)
                    generateLayer2(i);
            } else {
                generateLayer3();
            }
        } else if (strcmp(argv[i],"--test")==0 ||
                   strcmp(argv[i],"-t")==0 ) {
            char testPrefix[99];
            sprintf(testPrefix,"%s/digits/reference",CFG_DATAROOTDIR);
            //testFilterForDigit(testPrefix);
            generateTestData();
        } else if (strcmp(argv[i],"--help")==0 ||
                   strcmp(argv[i],"-h")==0 ) {
            digitsUsage(stdout,argv[0]);
            exit(0);
        } else {
            digitsUsage(stderr,argv[0]);
            ERROR("unknown option: ",argv[i]);
        }
        ++i;
    }
    return 0;
}

int main (int argc,char**argv) {
    char * progName = basename(argv[0]);
    if (strcmp(progName,"img")==0) {
        return imgMain(argc,argv);
    }
    if (strcmp(progName,"digits")==0) {
        return digitsMain(argc,argv);
    }
    ERROR("Unexpected program name: ",progName);
    return 0;
}
